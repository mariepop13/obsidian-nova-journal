name: Auto PR title/body
on:
  pull_request:
    types: [opened, edited, synchronize]
permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  set-title-body:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const {owner, repo, number} = context.issue;
            const pr = await github.rest.pulls.get({ owner, repo, pull_number: number });

            const ref = pr.data.head.ref || '';
            const [prefix, ...rest] = ref.split('/');
            const map = { feature: 'feat', fix: 'fix', hotfix: 'fix', refactor: 'refactor', chore: 'chore' };

            // Always compute a title from branch or first commit
            let title;
            if (map[prefix] && rest.length) {
              const subject = rest.join('/').replace(/[-_]/g, ' ');
              title = `${map[prefix]}: ${subject}`;
            } else {
              const commits = await github.paginate(github.rest.pulls.listCommits, { owner, repo, pull_number: number });
              const first = commits.find(c => !c.commit.message.startsWith('Merge'));
              title = first ? first.commit.message.split('\n')[0] : 'chore: update';
            }
            await github.rest.pulls.update({ owner, repo, pull_number: number, title });

            // Build an auto body from commits and files
            const commits = await github.paginate(github.rest.pulls.listCommits, { owner, repo, pull_number: number });
            const subjects = commits
              .map(c => (c.commit.message || '').split('\n')[0])
              .filter(s => s && !s.startsWith('Merge'))
              .slice(0, 30);

            const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: number });
            const areas = new Map();
            let additions = 0, deletions = 0, changes = 0;
            for (const f of files) {
              const top = (f.filename || '').split('/')[0] || '.';
              areas.set(top, (areas.get(top) || 0) + 1);
              additions += f.additions || 0;
              deletions += f.deletions || 0;
              changes += f.changes || 0;
            }
            const areaList = Array.from(areas.entries()).map(([d, c]) => `- ${d}: ${c} file(s)`).join('\n') || '- n/a';
            const commitList = subjects.map(s => `- ${s}`).join('\n') || '- Update';

            const body = `## Summary\n${title}\n\n## Changes\n${commitList}\n\n### Touched areas\n${areaList}\n\n## Testing\n- Build and basic manual checks\n\n## Notes\n- +${additions} / -${deletions}, ${changes} changes\n\n## Checklist\n- [ ] Build passes\n- [ ] Scope is small and focused\n`;
            await github.rest.pulls.update({ owner, repo, pull_number: number, body });

            // Auto label based on branch prefix
            const labels = [];
            if (prefix === 'feature') labels.push('Enhancement');
            if (prefix === 'fix' || prefix === 'hotfix') labels.push('Bug');
            if (prefix === 'chore') labels.push('Chore');
            if (prefix === 'refactor') labels.push('Refactor');
            if (labels.length) {
              try {
                await github.rest.issues.addLabels({ owner, repo, issue_number: number, labels });
              } catch (e) {
                core.warning(`Could not add labels: ${e.message}`);
              }
            }


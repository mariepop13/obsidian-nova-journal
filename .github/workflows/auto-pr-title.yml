name: Auto PR title/body + labels
on:
  pull_request_target:
    types: [opened, edited, synchronize, reopened, ready_for_review]
  issue_comment:
    types: [created]
permissions:
  contents: write
  pull-requests: write
  issues: write
concurrency:
  group: auto-pr-title-${{ github.workflow }}-${{ github.event.pull_request.number || github.event.issue.number || github.run_id }}
  cancel-in-progress: true

jobs:
  set-title-body:
    runs-on: ubuntu-latest
    timeout-minutes: 3
    steps:
      - uses: actions/github-script@v7
        env:
          OPENAI_KEY: ${{ secrets.OPENAI_KEY }}
        with:
          script: |
            const {owner, repo, number} = context.issue;
            const prNumber = context.payload?.pull_request?.number || context.payload?.issue?.number || number;
            core.info(`Event: ${context.eventName}; Action: ${context.payload?.action || ''}; PR #: ${prNumber}`);
            if (!prNumber) {
              core.warning('No PR number resolved from context; skipping.');
              return;
            }
            // Guard against forks: do not use secrets or mutate labels on forked PRs
            let pr;
            try {
              pr = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            } catch (e) {
              core.warning(`Failed to load PR #${prNumber}: ${e.message}`);
              return;
            }
            const actor = context.actor || '';
            const isBotActor = /\[bot\]$/.test(actor) || actor === 'dependabot[bot]';
            const isFork = !!pr?.data?.head?.repo?.fork;
            if (isFork) {
              core.warning('PR depuis un fork — on ne touche pas aux secrets ni aux labels.');
              return;
            }
            if (pr?.data?.draft && context.payload?.action !== 'ready_for_review' && context.eventName !== 'issue_comment') {
              core.info('Draft PR and no explicit command; skipping title/body/labels until ready_for_review.');
              return;
            }
            const isIssueComment = context.eventName === 'issue_comment' && !!context.payload?.issue?.pull_request;
            const commentBody = (context.payload?.comment?.body || '').trim();
            const commenterAssoc = context.payload?.comment?.author_association || '';
            const commenterAllowed = ['MEMBER','OWNER','COLLABORATOR'].includes(commenterAssoc);

            async function addLabels(labels) {
              if (!labels || labels.length === 0) return;
              await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels });
            }

            async function removeLabels(names) {
              if (!names || names.length === 0) return;
              for (const name of names) {
                try {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name });
                } catch (e) {
                  core.warning(`Could not remove label "${name}": ${e.message}`);
                }
              }
            }

            // Handle comment commands for labels and maintenance
            let forceRegenerate = false;
            let summarizeAsComment = false;
            let explicitRetitle = null;
            if (isIssueComment && commentBody) {
              if (!commenterAllowed) {
                core.info(`Skip label mutation from non-member commenter: ${commenterAssoc}`);
                return;
              }
              // /retitle New title here
              const mRetitle = commentBody.match(/^\s*\/retitle\s+(.+)$/i);
              if (mRetitle && mRetitle[1]) {
                explicitRetitle = mRetitle[1].trim();
                await github.rest.pulls.update({ owner, repo, pull_number: prNumber, title: explicitRetitle });
                return;
              }
              // /needs-review
              if (/^\s*\/needs-review\b/i.test(commentBody)) {
                await addLabels(['needs-review']);
                return;
              }
              // /labels a,b;c
              const mAdd = commentBody.match(/^\s*\/labels?\s*[:\s]+(.+)$/i);
              if (mAdd && mAdd[1]) {
                const list = mAdd[1].split(/[;,]/).map(s => s.trim()).filter(Boolean);
                if (list.length) await addLabels(list);
                return;
              }
              // /remove-label a,b
              const mRemove = commentBody.match(/^\s*\/remove-label\s+(.+)$/i);
              if (mRemove && mRemove[1]) {
                const list = mRemove[1].split(/[;,]/).map(s => s.trim()).filter(Boolean);
                if (list.length) await removeLabels(list);
                return;
              }
              // /clear-labels -> remove managed auto labels
              if (/^\s*\/clear-labels\b/i.test(commentBody)) {
                try {
                  const managedList = ['bug','documentation','enhancement','chore','refactor','needs-review','review effort 1/5','review effort 2/5','review effort 3/5','review effort 4/5','review effort 5/5'];
                  const existing = await github.rest.issues.listLabelsOnIssue({ owner, repo, issue_number: prNumber, per_page: 100 });
                  const toRemove = (existing.data || []).map(l => l.name).filter(n => managedList.includes(n.toLowerCase()) || n.toLowerCase().startsWith('review effort '));
                  for (const name of toRemove) {
                    try { await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name }); } catch {}
                  }
                } catch (e) {
                  core.warning(`Failed to clear labels: ${e.message}`);
                }
                return;
              }
              // /rebuild-body -> force regeneration of PR body and labels
              if (/^\s*\/rebuild-body\b/i.test(commentBody)) {
                forceRegenerate = true;
              }
              // /summarize -> post an AI summary as a comment
              if (/^\s*\/summarize\b/i.test(commentBody)) {
                summarizeAsComment = true;
                forceRegenerate = true;
              }
              // /relabel or /generate_labels -> fall through to heuristic labeling below
              if (!/^\s*\/(relabel|generate_labels|rebuild-body|summarize)\b/i.test(commentBody)) {
                // No recognized command; do nothing
                return;
              }
            }
            // 1) Add a fixed label when the PR becomes "Ready for review"
            if (context.payload?.action === 'ready_for_review') {
              try {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: prNumber,
                  labels: ['needs-review'],
                });
              } catch (e) {
                core.warning(`Could not add 'needs-review' label: ${e.message}`);
              }
            }

            const ref = pr.data.head.ref || '';
            const [prefix, ...rest] = ref.split('/');
            const map = { feature: 'feat', fix: 'fix', hotfix: 'fix', refactor: 'refactor', chore: 'chore' };

            // Always compute a title from branch or first commit
            let title;
            if (map[prefix] && rest.length) {
              const subject = rest.join('/').replace(/[-_]/g, ' ');
              title = `${map[prefix]}: ${subject}`;
            } else {
              const commits = await github.paginate(github.rest.pulls.listCommits, { owner, repo, pull_number: prNumber });
              const first = commits.find(c => !c.commit.message.startsWith('Merge'));
              title = first ? first.commit.message.split('\n')[0] : 'chore: update';
            }
            await github.rest.pulls.update({ owner, repo, pull_number: prNumber, title: explicitRetitle || title });

            // Build an auto body from commits and files
            const commits = await github.paginate(github.rest.pulls.listCommits, { owner, repo, pull_number: prNumber });
            const sanitizeSubject = (s) => s
              .replace(/^[:*_~`\s\p{Emoji_Presentation}\p{Extended_Pictographic}]+/u, '')
              .replace(/^(feat|fix|refactor|chore|docs|test|build|ci|bookmark|art|wrench)(\([^)]*\))?:\s*/i, '')
              .replace(/^(🔖|🎨|🔧|✨|🐛|📚|🚀|⚡|💡|🔒|🧪|📝|🎯|🔥|💚|👷|📊|🏗️|⬆️|⬇️|📌|👽|🍱|♿|💬|🗃️|🏷️|🚨|🚧|💥|🍻|💬|🔀|📦|👌|🎉|🎨)+\s*/u, '')
              .trim();
            const subjects = commits
              .map(c => (c.commit.message || '').split('\n')[0])
              .map(sanitizeSubject)
              .filter(s => s && !s.startsWith('Merge'))
              .slice(0, 30);

            const files = await github.paginate(github.rest.pulls.listFiles, { owner, repo, pull_number: prNumber });
            const areas = new Map();
            let additions = 0, deletions = 0, changes = 0;
            for (const f of files) {
              const top = (f.filename || '').split('/')[0] || '.';
              areas.set(top, (areas.get(top) || 0) + 1);
              additions += f.additions || 0;
              deletions += f.deletions || 0;
              changes += f.changes || 0;
            }
            const areaEntries = Array.from(areas.entries()).filter(([d]) => d !== '.github');
            const areaTop = areaEntries.sort((a,b)=>b[1]-a[1]).slice(0,3).map(([d])=>d).join('; ');
            const areaList = areaEntries.map(([d, c]) => `- ${d}: ${c} file(s)`).join('\n') || '- n/a';
            const keyChangesList = subjects.slice(0,7).map(s => `- ${s}`).join('\n') || '- Update';

            // Try AI summary with caching (if OPENAI_KEY provided)
            let aiSummary = '';
            try {
              const openaiKey = process.env.OPENAI_KEY || '';
              if (openaiKey) {
                const patches = files.map(f => (f.patch || '')).join('\n\n');
                const patchExcerpt = patches.slice(0, 12000);
                const fileListArray = files.map(f => `- ${f.status?.toUpperCase?.() || 'MOD'} ${f.filename}`);
                const commitSubjects = subjects.join('\n');
                
                // Create cache key from diff content hash
                const crypto = require('crypto');
                const diffHash = crypto.createHash('sha256')
                  .update(patchExcerpt + fileListArray.join('') + commitSubjects)
                  .digest('hex')
                  .slice(0, 16);
                
                const cacheKey = `ai-summary-${diffHash}`;
                
                // Try to get cached summary from PR comments
                let cachedSummary = '';
                try {
                  const comments = await github.paginate(github.rest.issues.listComments, {
                    owner, repo, issue_number: prNumber, per_page: 100
                  });
                  const cacheComment = comments.find(c => 
                    c.body?.includes(`<!-- CACHE:${cacheKey} -->`) && 
                    c.user?.login === 'github-actions[bot]'
                  );
                  if (cacheComment) {
                    const match = cacheComment.body.match(/<!-- CACHE:.*? -->\n([\s\S]*?)(?:\n<!-- \/CACHE -->|$)/);
                    if (match && match[1]) {
                      cachedSummary = match[1].trim();
                      core.info(`Using cached AI summary (${cacheKey})`);
                    }
                  }
                } catch (e) {
                  core.warning(`Cache lookup failed: ${e.message}`);
                }
                
                if (cachedSummary) {
                  aiSummary = cachedSummary;
                } else {
                  // Generate new AI summary
                  const prompt = `Summarize this PR concisely for reviewers in max 300 words. Focus on WHAT changed, not commit prefixes. Format: Summary (1 line), Key Changes (3-5 bullets describing actual changes), Risk (Low/Med/High), Testing notes.\n\nBranch: ${pr.data.head.ref}\nFiles:\n${fileListArray.slice(0, 10).join('\n')}\nCommits (ignore emoji/prefixes, focus on substance):\n${commitSubjects.slice(0, 5).join('\n')}\n\nCode:\n${patchExcerpt}`;

                  const resp = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json',
                      'Authorization': `Bearer ${openaiKey}`,
                    },
                    body: JSON.stringify({
                      model: 'gpt-5-mini',
                      messages: [
                        { role: 'system', content: 'You are an expert code reviewer and technical writer.' },
                        { role: 'user', content: prompt },
                      ],
                      temperature: 0.1,
                      max_tokens: 500,
                    }),
                  });
                  const data = await resp.json();
                  aiSummary = data?.choices?.[0]?.message?.content?.trim?.() || '';
                  
                  // Cache the result as a hidden comment
                  if (aiSummary && !forceRegenerate) {
                    try {
                      await github.rest.issues.createComment({
                        owner, repo, issue_number: prNumber,
                        body: `<!-- CACHE:${cacheKey} -->\n${aiSummary}\n<!-- /CACHE -->`
                      });
                      core.info(`Cached AI summary (${cacheKey})`);
                    } catch (e) {
                      core.warning(`Failed to cache summary: ${e.message}`);
                    }
                  }
                }
              } else {
                core.info('OPENAI_KEY not set; skipping AI summary.');
              }
              // Remove outer code fences like ```markdown ... ``` if the model wrapped the whole text
              const stripFences = (s) => {
                if (!s) return s;
                if (/^```[a-zA-Z]*\s*\n[\s\S]*\n```$/.test(s)) {
                  return s.replace(/^```[^\n]*\n/, '').replace(/\n```$/, '');
                }
                return s;
              };
              aiSummary = stripFences(aiSummary);
            } catch (e) {
              core.warning(`AI summary failed: ${e.message}`);
            }

            if (summarizeAsComment && aiSummary) {
              try {
                await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body: `## AI Summary\n\n${aiSummary}` });
              } catch (e) {
                core.warning(`Failed to post AI summary comment: ${e.message}`);
              }
              return;
            }
            // Dynamic diagram based on affected files
            let diagramNodes = ['  Main["NovaJournalPlugin (main.ts)"]'];
            let diagramEdges = [];
            
            const hasUI = files.some(f => f.filename.includes('ui/') || f.filename.includes('SettingsTab'));
            const hasPrompt = files.some(f => f.filename.includes('prompt/') || f.filename.includes('services/prompt'));
            const hasAI = files.some(f => f.filename.includes('ai/') || f.filename.includes('services/ai'));
            const hasStyles = files.some(f => f.filename.includes('styles.css') || f.filename.includes('.css'));
            const hasTests = files.some(f => f.filename.includes('test') || f.filename.includes('spec'));
            const hasConfig = files.some(f => f.filename.includes('manifest.json') || f.filename.includes('package.json'));
            
            if (hasUI) {
              diagramNodes.push('  UI["UI Components (ui/)"]');
              diagramEdges.push('  Main --> UI');
            }
            
            if (hasPrompt) {
              diagramNodes.push('  Prompt["Prompt Services (services/prompt/)"]');
              diagramEdges.push('  Main --> Prompt');
              if (hasUI) diagramEdges.push('  UI --> Prompt');
            }
            
            if (hasAI) {
              diagramNodes.push('  AI["AI Services (services/ai/)"]');
              diagramEdges.push('  Main --> AI');
              if (hasPrompt) diagramEdges.push('  Prompt --> AI');
              
              // Add specific AI components if files are modified
              const aiFiles = files.filter(f => f.filename.includes('services/ai/'));
              aiFiles.forEach(f => {
                const basename = f.filename.split('/').pop().replace('.ts', '');
                if (basename === 'RagContextService') {
                  diagramNodes.push('  RAG["RagContextService"]');
                  diagramEdges.push('  AI --> RAG');
                } else if (basename === 'EnhancedEmbeddingService') {
                  diagramNodes.push('  Embed["EnhancedEmbeddingService"]');
                  diagramEdges.push('  AI --> Embed');
                } else if (basename.includes('Prompt')) {
                  diagramNodes.push('  PromptGen["Prompt Generation"]');
                  diagramEdges.push('  AI --> PromptGen');
                }
              });
            }
            
            if (hasStyles) {
              diagramNodes.push('  Styles["Styles (styles.css)"]');
              diagramEdges.push('  UI --> Styles');
            }
            
            if (hasTests) {
              diagramNodes.push('  Tests["Test Suite"]');
              diagramEdges.push('  Tests -.-> Main');
              if (hasAI) diagramEdges.push('  Tests -.-> AI');
              if (hasPrompt) diagramEdges.push('  Tests -.-> Prompt');
            }
            
            if (hasConfig) {
              diagramNodes.push('  Config["Configuration"]');
              diagramEdges.push('  Config -.-> Main');
            }
            
            const diagram = [
              '```mermaid',
              'flowchart LR',
              ...diagramNodes,
              ...diagramEdges,
              '```',
            ].join('\n');

            const fileWalk = files.map(f => `- ${f.filename} (${(f.status || 'modified').toLowerCase()})`).join('\n') || '- n/a';

            const CHANGE_LIMIT = 300;
            const FILE_LIMIT = 15;
            const scopeOk = changes <= CHANGE_LIMIT && files.length <= FILE_LIMIT;
            const scopeReasons = [];
            if (changes > CHANGE_LIMIT) scopeReasons.push(`${changes} changes > ${CHANGE_LIMIT}`);
            if (files.length > FILE_LIMIT) scopeReasons.push(`${files.length} files > ${FILE_LIMIT}`);
            const scopeReason = scopeReasons.join('; ');
            const checklist = `- [${scopeOk ? 'x' : ' '}] Scope is small and focused${scopeOk ? '' : ` – ${scopeReason}`}`;

            const aiFirstLine = (aiSummary || '').split('\n').find(l => l.trim().length > 0) || '';
            const summaryLine = aiFirstLine || (subjects[0] ? subjects[0] : title);

            // Risk heuristic
            const risk = (changes > 600 || files.length > 25) ? 'High' : (changes > 300 || files.length > 12) ? 'Medium' : 'Low';

            // Dynamic testing section based on affected areas
            let testingSection = '- Manual: run Nova Journal commands and verify functionality';
            if (areaTop.includes('ai') || areaTop.includes('services')) {
              testingSection = '- Manual: test AI services and RAG functionality\n- Verify prompt generation and context retrieval';
            } else if (areaTop.includes('ui') || areaTop.includes('styles')) {
              testingSection = '- Manual: test UI components and styling\n- Verify responsive design and accessibility';
            } else if (areaTop.includes('test')) {
              testingSection = '- Run: `npm test` to validate test suite\n- Check test coverage and assertions';
            }

            const body = `## Summary\n${summaryLine}\n\n## Key Changes\n${keyChangesList}\n\n## Impact\n- Risk: ${risk}\n- Affected areas: ${areaTop || 'n/a'}\n\n## Testing\n${testingSection}\n\n---\n\n### Diagram\n\n${diagram}\n\n<details><summary><h3>Files Touched</h3></summary>\n\n${fileWalk}\n\n</details>\n\n## Meta\n- +${additions} / -${deletions}, ${changes} changes\n\n## Checklist\n${checklist}\n`;
            await github.rest.pulls.update({ owner, repo, pull_number: prNumber, body });

            // Auto labels (default GitHub names + review effort)
            const labelSet = new Set();

            // Prefix-based labels
            if (prefix === 'feature') labelSet.add('enhancement');
            if (prefix === 'fix' || prefix === 'hotfix') labelSet.add('bug');
            if (prefix === 'docs') labelSet.add('documentation');
            if (prefix === 'chore') labelSet.add('chore');
            if (prefix === 'refactor') labelSet.add('refactor');

            // File-based heuristics
            const mdCount = files.filter(f => (f.filename || '').toLowerCase().endsWith('.md')).length;
            const docsFolderCount = files.filter(f => (f.filename || '').toLowerCase().startsWith('docs/')).length;
            if ((mdCount + docsFolderCount) > 0) labelSet.add('documentation');

            // Review effort label based on diff size
            const effort = changes > 600 ? 5 : changes > 300 ? 4 : changes > 150 ? 3 : changes > 75 ? 2 : 1;
            const effortLabel = `Review effort ${effort}/5`;
            labelSet.add(effortLabel);

            // Ensure one mandatory category label is always applied
            const mandatoryCategories = ['bug', 'documentation', 'enhancement', 'chore', 'refactor'];
            const hasCategory = mandatoryCategories.some(c => labelSet.has(c));
            if (!hasCategory) {
              // Fallback default if no category matched heuristics
              labelSet.add('enhancement');
            }

            // Ensure labels exist (create if missing)
            async function ensureLabel(name, color = 'a371f7', description = '') {
              try {
                await github.rest.issues.getLabel({ owner, repo, name });
              } catch (e) {
                if (e.status === 404) {
                  try {
                    await github.rest.issues.createLabel({ owner, repo, name, color, description });
                  } catch (e2) {
                    core.warning(`Could not create label "${name}": ${e2.message}`);
                  }
                } else {
                  core.warning(`Get label failed for "${name}": ${e.message}`);
                }
              }
            }
            // Proactively ensure common labels
            await Promise.allSettled([
              ensureLabel('bug', 'd73a4a', 'Something isn\'t working'),
              ensureLabel('documentation', '0075ca', 'Improvements or additions to documentation'),
              ensureLabel('enhancement', 'a2eeef', 'New feature or request'),
              ensureLabel('chore', 'ededed', 'Chore or maintenance'),
              ensureLabel('refactor', '0366d6', 'Code refactor'),
              ensureLabel('needs-review', '0e8a16', 'Ready for review'),
              ensureLabel(effortLabel, 'a371f7', 'Estimated review effort')
            ]);

            // Overwrite previously auto-applied labels
            try {
              const desired = Array.from(labelSet);
              const desiredLower = new Set(desired.map(n => n.toLowerCase()));
              const managedList = ['bug','documentation','enhancement','chore','refactor','needs-review','review effort 1/5','review effort 2/5','review effort 3/5','review effort 4/5','review effort 5/5'];
              const existing = await github.rest.issues.listLabelsOnIssue({ owner, repo, issue_number: prNumber, per_page: 100 });
              const existingNames = (existing.data || []).map(l => l.name);
              core.info(`Existing labels: ${existingNames.join(', ') || '(none)'}`);
              core.info(`Desired labels: ${desired.join(', ') || '(none)'}`);
              core.info(`Managed categories: ${managedList.join(', ')}`);
              const toRemove = (existing.data || [])
                .map(l => l.name)
                .filter(name => {
                  const lower = name.toLowerCase();
                  const isManagedCategory = managedList.includes(lower);
                  const isManagedEffort = lower.startsWith('review effort ');
                  const keep = desiredLower.has(lower);
                  return (isManagedCategory || isManagedEffort) && !keep;
                });
              core.info(`Managed labels to remove: ${toRemove.join(', ') || '(none)'}`);
              for (const name of toRemove) {
                try {
                  core.info(`Removing label: ${name}`);
                  await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name });
                  core.info(`Removed label: ${name}`);
                } catch (e) {
                  core.warning(`Remove label failed for ${name}: ${e.message}`);
                }
              }
              if (desired.length) {
                core.info(`Applying labels: ${desired.join(', ')}`);
                await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: desired });
                core.info('Labels added successfully');
              } else core.info('No labels to add');
            } catch (e) {
              core.warning(`Could not add labels: ${e.message}`);
            }

